# Ilhabela

```

1、进程间通信
pool 需要manager中的queue
多进程中的queue 是不能进行通信的

可以使用pipe 进行进程间的通信,只适用于两个进程间的通信

也可以使用共享内存的方式实现  Manager.dict()

2、GIL 实现多线程 线程间的通信 queue 是线程安全的

线程间的通信  lock Rlock semaphore Condition
最好使用queue

优先级的队列

3、协程

并发 ：一个时间段内，有几个程序在同一个cpu上运行，但是任意时刻只有一个程序在cpu上运行；
并行：在某一时刻 有几个程序在多个cpu上运行；

同步: 调用io操作的时候 需要等待
异步: 不需要等待io操作的结果

阻塞：调用函数的时候当前线程被挂起
非阻塞：调用函数的时候，当前线程不会被挂起，而是立即返回、。、

4、C10k
C10K问题的本质上是操作系统的问题。
对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。
当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。
可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。

5、IO多路复用
Unix 下的五种io模型

阻塞式IO


非阻塞式

io复用

信号驱动式

每个进程/线程同时处理 多个连接(I/O多路复用)

select方式：
使用fd_set结构体告诉内核同时监控那些文件句柄，
使用逐个排查方式去检查是否有文件句柄就绪或者超时。
该方式有以下缺点：
    文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。
poll方式：
    该方式主要解决了select方式的2个缺点，
    文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件和发生事件)，
    但是逐个去检查文件句柄是否就绪的问题仍然没有解决。
epoll方式：
    该方式可以说是C10K问题的killer，
    他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。
    其工作机制是，使用"事件"的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。

异步I/O以及Windows，该方式在windows上支持很好，

```

## asyncio

```
进行异步io并发编程
核心模块 3.4之后


```

### 1、事件循环

```
1、包含各种特定系统实现的模块化事件循环 window select
2、传输和协议抽象
3、对tcp udp ssl 子进程 延时调用
4、模仿futures 模块 但是适用于事件循环，使用的future类
5、基于yield from 的协议和人物，可以让你用顺序的方式编写并发代码
6、必须使用一个将产生阻塞io的调用时，有接口可以把这个事件转移到线程池
协程调度
7、模仿threading 模块中的同步元鱼 可以用在单线程内的协程之间


how to use
```


```
学习
https://github.com/aio-libs
```

